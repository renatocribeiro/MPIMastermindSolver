//
// Created by rena on 07.11.19.
//

#include "Challenger.h"

/**
 * Constructs a Challenger object from a given challenger id, length of secret, number of colors and a starting range.
 * @param challenger_id id in the challenger communication group
 * @param size_secret length of secret
 * @param nbr_color number of colors of secret
 * @param range starting range of guesses
 */
Challenger::Challenger(const int &challenger_id, const int &size_secret, const int &nbr_color, Range range) {
    _chall_id = challenger_id;
    _size_secret= size_secret;
    _nbr_colors = nbr_color;
    _ranges.push_back(range);

}


/**
 * Generates as many partitions as challengers in game from a given number of possible guesses. The partitions are
 * stored in the local vector.
 * @param local Resulting partitions will be stored here.
 * @param challengers_size number of challengers in game
 * @param total_guesses_left total of guesses which must be partitioned among the challengers
 */
void Challenger::generate_partitions(std::vector<type_guess> &local, int challengers_size, type_guess total_guesses_left) {
    type_guess partition_size = ceil(total_guesses_left / challengers_size);

    local = std::vector<type_guess> (challengers_size, partition_size);
    type_guess off = total_guesses_left - (partition_size * challengers_size);
    local.at(challengers_size -1 ) = local.at(challengers_size - 1) + off;

}

/**
 * Compared a given guess against all the previous guesses/evaluations received from the gamemaster.
 * @param guess possible plausible guess
 * @return true if guess is plausible, false otherwise.
 */
bool Challenger::_is_plausible(Guess &guess) {
    for(size_t i = 0; i<_prev_guesses.size(); i++){
        if(_prev_guesses[i].evaluate(guess, _size_secret) != _prev_evals[i]){
            return false;
        }
    }
    return true;
}

/**
 * Looks for a plausible guess in its ranges. If a guess is found it will be returned and the current
 * range's lower bound will be shortened to the same guess value. If a guess isn't found, an invalid guess is returned.
 * @return
 */
Guess Challenger::get_guess(){
    Guess res;
    if(_prev_guesses.size() < 1){
        //if first round, returns first guess
        return Guess(_ranges[0].from, _size_secret, _nbr_colors);
    }else{
        //looks for a plausible guess
        for(size_t r = _ranges.size(); r-- > 0;){
            for(type_guess i = _ranges[r].from; i<_ranges[r].end; i++) {
                Guess tmp_guess = Guess(i, _size_secret, _nbr_colors);
                bool pl = _is_plausible(tmp_guess);
                if(pl){
                    _ranges[r].from = i;
                    return tmp_guess;
                }
            }
            _ranges.pop_back();
        }
    }
    return res;
}

/**
 * Updated the challenger with the latest guess and evaluation received from the gamemaster.
 * @param last_guess last picked guess by the gamemaster
 * @param last_evaluation last evaluation received from the gamemaster
 */
void Challenger::update(Guess &last_guess, Evaluation last_evaluation) {
    _prev_guesses.push_back(last_guess);
    _prev_evals.push_back(last_evaluation);

}

/**
 * Displays the current ranges.
 */
void Challenger::display() {
    for(size_t r = 0; r<_ranges.size(); r++) {
        for(size_t i = _ranges[r].from; i<_ranges[r].end; i++){
            std::cout<<"chid: "<<_chall_id<<", r: "<<r<<"nbr: "<<i<<std::endl;
        }
    }

}

/**
 * Moves the current ranges to a given vector of Range objects.
 * @param ranges challenger's ranges will be moved here.
 */
void Challenger::get_ranges(std::vector<Range> & ranges) {
    ranges = std::move(_ranges);
}

/**
 * New ranges generated by the Challenger's root will be moved to current Challenger's ranges.
 * @param ranges new ranges
 */
void Challenger::set_ranges(std::vector<Range> & ranges) {
    _ranges = std::move(ranges);
}

/**
 * This static method is meant to be used by the Challengers root node. It will generate/distribute new
 * ranges and set them in the new_ranges vector. This process will be based on the previous ranges (given by
 * old_ranges) and the total size of challengers in game. The distribution of the number of ranges per challengers
 * will be set in new_range_distr. E.g: If new_ranges contains the ranges [0, 10], [37, 39] and [45, 189] and
 * new_range_distr contains the numbers 2 and 1, it means that the Challenger number 1 should receive the first 2
 * ranges and the Challenger number 2 should receive the last one.
 * @param new_ranges newly computed ranges will be here
 * @param new_range_distr contains the distribution of ranges per challenger
 * @param old_ranges old ranges which were sent by the challengers to be redistributed
 * @param challengers_size number of challengers in game
 */
void Challenger::generate_new_ranges(std::vector<Range> & new_ranges, std::vector<int> &new_range_distr, std::vector<Range> & old_ranges, int & challengers_size) {

    //generated new partitions for each challenger
    type_guess total = 0;
    for(auto f: old_ranges) total += f.end - f.from;
    std::vector<type_guess> local;
    Challenger::generate_partitions(local, challengers_size, total);

    //distributes actual ranges for each challenger
    new_range_distr = std::vector<int>(challengers_size, 0);
    Range current_range = old_ranges.back();
    old_ranges.pop_back();
    int current_partition;
    type_guess diff;
    for(size_t i = 0; i<local.size(); i++){
        current_partition = local[i];
        while(current_partition > 0){
            if(current_range.size() > current_partition){
                diff = current_range.size() - current_partition;
                current_partition = 0;
                Range new_range;
                new_range.from = current_range.from;
                new_range.end = current_range.end - diff;
                new_ranges.push_back(new_range);
                current_range.from = current_range.end - diff;
            }
            else if(current_range.size() < current_partition){
                current_partition -= current_range.size();
                new_ranges.push_back(current_range);
                current_range = old_ranges.back();
                old_ranges.pop_back();
            }
            else {
                current_partition = 0;
                new_ranges.push_back(current_range);
                current_range = old_ranges.back();
                old_ranges.pop_back();
            }
            new_range_distr[i]++;
        }
    }
}

/**
 * Same as the other but it is only meant to be used before the games starts. It generates the default ranges
 * for each challenger.
 * @param new_ranges
 * @param challengers_size
 * @param total_guesses_left
 */
void Challenger::generate_new_ranges(std::vector<Range> & new_ranges, int challengers_size, type_guess total_guesses_left) {
    std::vector<type_guess> local;
    Challenger::generate_partitions(local, challengers_size, total_guesses_left);

    type_guess previous = 0;
    for(size_t i = 0; i<challengers_size; i++){
        type_guess tmp_from = previous;
        previous = tmp_from + local[i];
        type_guess tmp_end = previous;
        new_ranges.push_back(Range(tmp_from, tmp_end));
    }
}